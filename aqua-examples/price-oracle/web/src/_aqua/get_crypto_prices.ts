/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/.
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.3.2-233
 *
 */
import { Fluence, FluencePeer } from '@fluencelabs/fluence';
import {
    ResultCodes,
    RequestFlow,
    RequestFlowBuilder,
    CallParams
} from '@fluencelabs/fluence/dist/internal/compilerSupport/v1';


function missingFields(obj: any, fields: string[]): string[] {
    return fields.filter(f => !(f in obj))
}

// Services

export interface PriceGetterServiceDef {
    price_getter: (coin: string, currency: string, timestamp_ms: number, callParams: CallParams<'coin' | 'currency' | 'timestamp_ms'>) => { error_msg: string; result: number; success: boolean; };
}
export function registerPriceGetterService(serviceId: string, service: PriceGetterServiceDef): void;
export function registerPriceGetterService(peer: FluencePeer, serviceId: string, service: PriceGetterServiceDef): void;
       

export function registerPriceGetterService(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    } 

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

    const incorrectServiceDefinitions = missingFields(service, ['price_getter']);
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service PriceGetterService: missing functions: " + incorrectServiceDefinitions.map((d) => "'" + d + "'").join(", "))
    }

    peer.internals.callServiceHandler.use((req, resp, next) => {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }

        if (req.fnName === 'price_getter') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    coin: req.tetraplets[0],currency: req.tetraplets[1],timestamp_ms: req.tetraplets[2]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.price_getter(req.args[0], req.args[1], req.args[2], callParams)
        }

        next();
    });
}
      


export interface MeanServiceDef {
    mean: (data: number[], callParams: CallParams<'data'>) => { error_msg: string; result: number; success: boolean; };
}
export function registerMeanService(serviceId: string, service: MeanServiceDef): void;
export function registerMeanService(peer: FluencePeer, serviceId: string, service: MeanServiceDef): void;
       

export function registerMeanService(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    } 

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

    const incorrectServiceDefinitions = missingFields(service, ['mean']);
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service MeanService: missing functions: " + incorrectServiceDefinitions.map((d) => "'" + d + "'").join(", "))
    }

    peer.internals.callServiceHandler.use((req, resp, next) => {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }

        if (req.fnName === 'mean') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    data: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.mean(req.args[0], callParams)
        }

        next();
    });
}
      


export interface F64OpDef {
    identity: (x: number, callParams: CallParams<'x'>) => number;
}
export function registerF64Op(service: F64OpDef): void;
export function registerF64Op(serviceId: string, service: F64OpDef): void;
export function registerF64Op(peer: FluencePeer, service: F64OpDef): void;
export function registerF64Op(peer: FluencePeer, serviceId: string, service: F64OpDef): void;
       

export function registerF64Op(...args: any) {
    let peer: FluencePeer;
    let serviceId: any;
    let service: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
    } else {
        peer = Fluence.getPeer();
    }

    if (typeof args[0] === 'string') {
        serviceId = args[0];
    } else if (typeof args[1] === 'string') {
        serviceId = args[1];
    } else {
        serviceId = "op"
    }

    // Figuring out which overload is the service.
    // If the first argument is not Fluence Peer and it is an object, then it can only be the service def
    // If the first argument is peer, we are checking further. The second argument might either be
    // an object, that it must be the service object
    // or a string, which is the service id. In that case the service is the third argument
    if (!(FluencePeer.isInstance(args[0])) && typeof args[0] === 'object') {
        service = args[0];
    } else if (typeof args[1] === 'object') {
        service = args[1];
    } else {
        service = args[2];
    }

    const incorrectServiceDefinitions = missingFields(service, ['identity']);
    if (!!incorrectServiceDefinitions.length) {
        throw new Error("Error registering service F64Op: missing functions: " + incorrectServiceDefinitions.map((d) => "'" + d + "'").join(", "))
    }

    peer.internals.callServiceHandler.use((req, resp, next) => {
        if (req.serviceId !== serviceId) {
            next();
            return;
        }

        if (req.fnName === 'identity') {
            const callParams = {
                ...req.particleContext,
                tetraplets: {
                    x: req.tetraplets[0]
                },
            };
            resp.retCode = ResultCodes.success;
            resp.result = service.identity(req.args[0], callParams)
        }

        next();
    });
}
      
// Functions
 
export type Get_priceResult = { error_msg: string; result: number; success: boolean; }
export function get_price(coin: string, currency: string, node: string, pg_sid: string, mean_sid: string, config?: {ttl?: number}): Promise<Get_priceResult>;
export function get_price(peer: FluencePeer, coin: string, currency: string, node: string, pg_sid: string, mean_sid: string, config?: {ttl?: number}): Promise<Get_priceResult>;
export function get_price(...args: any) {
    let peer: FluencePeer;
    let coin: any;
    let currency: any;
    let node: any;
    let pg_sid: any;
    let mean_sid: any;
    let config: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
        coin = args[1];
        currency = args[2];
        node = args[3];
        pg_sid = args[4];
        mean_sid = args[5];
        config = args[6];
    } else {
        peer = Fluence.getPeer();
        coin = args[0];
        currency = args[1];
        node = args[2];
        pg_sid = args[3];
        mean_sid = args[4];
        config = args[5];
    }

    let request: RequestFlow;
    const promise = new Promise<Get_priceResult>((resolve, reject) => {
        const r = new RequestFlowBuilder()
                .disableInjections()
                .withRawScript(`
                    (xor
                     (seq
                      (seq
                       (seq
                        (seq
                         (seq
                          (seq
                           (seq
                            (seq
                             (seq
                              (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
                              (call %init_peer_id% ("getDataSrv" "coin") [] coin)
                             )
                             (call %init_peer_id% ("getDataSrv" "currency") [] currency)
                            )
                            (call %init_peer_id% ("getDataSrv" "node") [] node)
                           )
                           (call %init_peer_id% ("getDataSrv" "pg_sid") [] pg_sid)
                          )
                          (call %init_peer_id% ("getDataSrv" "mean_sid") [] mean_sid)
                         )
                         (call -relay- ("op" "noop") [])
                        )
                        (xor
                         (seq
                          (seq
                           (seq
                            (seq
                             (seq
                              (seq
                               (seq
                                (call node ("op" "string_to_b58") [node] k)
                                (call node ("peer" "timestamp_ms") [] ts_ms0)
                               )
                               (call node (pg_sid "price_getter") [coin currency ts_ms0] res0)
                              )
                              (call node ("op" "identity") [res0.$.result!] $prices)
                             )
                             (call node ("peer" "timestamp_ms") [] ts_ms1)
                            )
                            (call node (pg_sid "price_getter") [coin currency ts_ms1] res1)
                           )
                           (call node ("op" "identity") [res1.$.result!] $prices)
                          )
                          (call node (mean_sid "mean") [$prices] result)
                         )
                         (seq
                          (call -relay- ("op" "noop") [])
                          (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
                         )
                        )
                       )
                       (call -relay- ("op" "noop") [])
                      )
                      (xor
                       (call %init_peer_id% ("callbackSrv" "response") [result])
                       (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
                      )
                     )
                     (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 3])
                    )
                `,
                )
                .configHandler((h) => {
                    h.on('getDataSrv', '-relay-', () => {
                        return peer.getStatus().relayPeerId;
                    });
                    h.on('getDataSrv', 'coin', () => {return coin;});
                    h.on('getDataSrv', 'currency', () => {return currency;});
                    h.on('getDataSrv', 'node', () => {return node;});
                    h.on('getDataSrv', 'pg_sid', () => {return pg_sid;});
                    h.on('getDataSrv', 'mean_sid', () => {return mean_sid;});
                    h.onEvent('callbackSrv', 'response', (args) => {
                        const [res] = args;
                        resolve(res);
                    });
                    h.onEvent('errorHandlingSrv', 'error', (args) => {
                        const [err] = args;
                        reject(err);
                    });
                })
                .handleScriptError(reject)
                .handleTimeout(() => {
                    reject('Request timed out for get_price');
                })

                if (config && config.ttl) {
                    r.withTTL(config.ttl)
                }

                request = r.build();
    });
    peer.internals.initiateFlow(request!);
    return promise;
}

export type Get_price_parArgMean_topo = { node: string; service_id: string; } 
export type Get_price_parResult = { error_msg: string; result: number; success: boolean; }
export function get_price_par(coin: string, currency: string, getter_topo: { node: string; service_id: string; }[], mean_topo: Get_price_parArgMean_topo, config?: {ttl?: number}): Promise<Get_price_parResult>;
export function get_price_par(peer: FluencePeer, coin: string, currency: string, getter_topo: { node: string; service_id: string; }[], mean_topo: Get_price_parArgMean_topo, config?: {ttl?: number}): Promise<Get_price_parResult>;
export function get_price_par(...args: any) {
    let peer: FluencePeer;
    let coin: any;
    let currency: any;
    let getter_topo: any;
    let mean_topo: any;
    let config: any;
    if (FluencePeer.isInstance(args[0])) {
        peer = args[0];
        coin = args[1];
        currency = args[2];
        getter_topo = args[3];
        mean_topo = args[4];
        config = args[5];
    } else {
        peer = Fluence.getPeer();
        coin = args[0];
        currency = args[1];
        getter_topo = args[2];
        mean_topo = args[3];
        config = args[4];
    }

    let request: RequestFlow;
    const promise = new Promise<Get_price_parResult>((resolve, reject) => {
        const r = new RequestFlowBuilder()
                .disableInjections()
                .withRawScript(`
                    (xor
                     (seq
                      (seq
                       (seq
                        (seq
                         (seq
                          (seq
                           (seq
                            (seq
                             (seq
                              (seq
                               (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
                               (call %init_peer_id% ("getDataSrv" "coin") [] coin)
                              )
                              (call %init_peer_id% ("getDataSrv" "currency") [] currency)
                             )
                             (call %init_peer_id% ("getDataSrv" "getter_topo") [] getter_topo)
                            )
                            (call %init_peer_id% ("getDataSrv" "mean_topo") [] mean_topo)
                           )
                           (fold getter_topo topo
                            (par
                             (seq
                              (seq
                               (seq
                                (call -relay- ("op" "noop") [])
                                (xor
                                 (seq
                                  (seq
                                   (seq
                                    (call topo.$.node! ("op" "string_to_b58") [topo.$.node!] k)
                                    (call topo.$.node! ("peer" "timestamp_ms") [] ts_ms)
                                   )
                                   (call topo.$.node! (topo.$.service_id! "price_getter") [coin currency ts_ms] res)
                                  )
                                  (call topo.$.node! ("op" "identity") [res.$.result!] $prices)
                                 )
                                 (seq
                                  (call -relay- ("op" "noop") [])
                                  (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
                                 )
                                )
                               )
                               (call -relay- ("op" "noop") [])
                              )
                              (call %init_peer_id% ("op" "noop") [])
                             )
                             (next topo)
                            )
                           )
                          )
                          (call %init_peer_id% ("op" "identity") [$prices.$.[2]!])
                         )
                         (call -relay- ("op" "noop") [])
                        )
                        (xor
                         (seq
                          (call -relay- ("op" "noop") [])
                          (call mean_topo.$.node! (mean_topo.$.service_id! "mean") [$prices] result)
                         )
                         (seq
                          (call -relay- ("op" "noop") [])
                          (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
                         )
                        )
                       )
                       (call -relay- ("op" "noop") [])
                      )
                      (xor
                       (call %init_peer_id% ("callbackSrv" "response") [result])
                       (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 3])
                      )
                     )
                     (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 4])
                    )
                `,
                )
                .configHandler((h) => {
                    h.on('getDataSrv', '-relay-', () => {
                        return peer.getStatus().relayPeerId;
                    });
                    h.on('getDataSrv', 'coin', () => {return coin;});
                    h.on('getDataSrv', 'currency', () => {return currency;});
                    h.on('getDataSrv', 'getter_topo', () => {return getter_topo;});
                    h.on('getDataSrv', 'mean_topo', () => {return mean_topo;});
                    h.onEvent('callbackSrv', 'response', (args) => {
                        const [res] = args;
                        resolve(res);
                    });
                    h.onEvent('errorHandlingSrv', 'error', (args) => {
                        const [err] = args;
                        reject(err);
                    });
                })
                .handleScriptError(reject)
                .handleTimeout(() => {
                    reject('Request timed out for get_price_par');
                })

                if (config && config.ttl) {
                    r.withTTL(config.ttl)
                }

                request = r.build();
    });
    peer.internals.initiateFlow(request!);
    return promise;
}
