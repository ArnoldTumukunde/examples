# EVM Integration Examples

## Overview

The [Ethereum virtual machine](https://ethereum.org/en/developers/docs/evm/) (EVM) is available across a variety of L1, L2 and sidechains with implementations ranging from straight clones to [compatible or equivalent](https://metisdao.medium.com/evm-equivalence-vs-evm-compatibility-199bd66f455d) implementation. [Ethereum JSON RPC](https://ethereum.github.io/execution-apis/api-documentation/) is the base API to access EVM functionality and the underlying request model for the various web3 libraries such as [ethers](https://docs.ethers.io/v5/) or [ethers-rs](https://docs.rs/ethers/0.1.3/ethers/). In theory, and sometimes even practice, this allows developers to reuse their contracts and Web3 code across different chains with no changes but a few parameters.

While many of the various EVM chains provide the Web3 benefits desired, running (blockchain) clients tends to be a resource intensive adventure. Not surprisingly, a myriad of hosted node providers, such as [Infura](https://infura.io/), [Alchemy](https://www.alchemy.com/) and many more, provide relatively cheap access and convenience APIs to a variety of chain clients. Alas, the benefits of convenience, possibly performance and low-to-no cost, comes at the price of introducing a single point of failure and a high exit barriers when adopting a hosting provider's specific API, thereby introducing a nontrivial chokepoint in your DApp. Morallis has a [PoV](https://moralis.io/ethereum-rpc-nodes-what-they-are-and-why-you-shouldnt-use-them/) suggesting developers abandon open and common standards and to lock into custom APIs with high exit barriers. Of course, we'll ignore this rather self-serving piece of advice and embark on a journey in line with our Web3 ethos.

In this tutorial, we illustrate how Fluence and Aqua can help DApp developers minimize and even eliminate centralized points of failure undermining the Web3 benefits of their DApp.


## Setting Up

If you haven't set up your Fluence and Aqua development environment, head over to the [setup docs](https://doc.fluence.dev/docs/tutorials_tutorials/recipes_setting_up); if you're not familiar with Fluence and Aqua, give the [developer docs](https://doc.fluence.dev) a gander.

In oder to actively participate, you ought to [sign up](##Selecting-Providers) for a few hosted (EVM) node providers with JSON-RPC access.

## Oracleizing Hosting Provider Responses

Centralized hosted nodes introduce at best a single point of failure and at worst, a nefarious actor creating havoc in your DApp. Regardless, a centralized source of truth easily negates the benefits of a decentralized backend. Without giving up all of the convenience and cost savings, who wants to run a 3 TB node on AWS anyway, we can route identical requests to multiple hosted providers and determine,  against some quorum, the acceptability of the responses. That is, we [oracleize](https://en.wikipedia.org/wiki/Blockchain_oracle) hosted provider responses. See Figure 1.

```mermaid
    sequenceDiagram
    title: Figure 1: Stylize Oracle Over Multiple Host Providers

    participant C as Client
    participant R  as Relay node
    participant Pi as P2P Network

    loop for some nodes
        C -> Pi: Deploy provider adapter
        Pi -> C: Deployed provider service metadata  
    end
    
    C -> Pi: Deploy quorum service to one node
    Pi -> C: Deployed quorum service metadata  


    par for all provider urls
        R -> Pi: JSON-RPC Request
        Pi -> R: JSON-RPC Response
    end
    
    R -> Pi: Evaluate JSON-RPC responses
    Pi -> R: Accept or Reject provider(s) or provider responses

    opt data to client peer
        R -> C: provider responses, quorum, etc.
    end
```

### Provider Adapter

In order to interact with the hosted EVms, we choose the lowest common API denominator, i.e., Ethereum JSON-RPC, which provides us with flexibility and great reuse.

For illustrative purposes, let's say we want to make sure the provider is returning the `latest` block, which, while simple, is a pretty good indicator of provider "liveness." The JSON-RPC method we want to call is [`eth_blockNumber`](https://ethereum.github.io/execution-apis/api-documentation/) which formats to the following request:

```json
{
    "jsonrpc": "2.0",
    "method": "eth_blockNumber",
    "params": [],
    "id": 0
}
```

where `id` is the nonce. If we were to use `curl` on the command line:

```bash
curl --data '{"method":"eth_blockNumber","params":[],"id":1,"jsonrpc":"2.0"}' -H "Content-Type: application/json" -X POST <node or provider url>
```

we expect the following result:

```json
{
  "id": 1,
  "jsonrpc": "2.0",
  "result": "0x4b7" // hex encoded latest block
}
```

Ok, let's create an Wasm service we can use to query providers. Keep the curl command in mind as we'll need to use curl from our Wasm module to make the provider call.

`cd` into the `multi-provider-query` directory and have a look at `src/main.rs`:

```rust
// src/main.rs
#[marine]
// see https://eth.wiki/json-rpc/API#eth_blocknumbers
fn get_block_number(provider: ProviderInfo) -> EVMResult {
    let method = "eth_blockNumber";
    let params: Vec<String> = vec![];
    let url = provider.url;

    let data = RpcData::new(method.to_owned(), params);
    let data = serde_json::to_string(&data).unwrap();

    let curl_cmd = curl_cmd_builder(url, data);
    let response = get_curl_response(curl_cmd);

    if response.error.is_none() {
        let raw_response = response.result.unwrap();
        let block_height = u64::from_str_radix(raw_response.trim_start_matches("0x"), 16);

        let result = match block_height {
            Ok(r) => {
                let j_res = serde_json::json!({ "block-heigh": r });
                EVMResult {
                    stdout: j_res.to_string(),
                    stderr: "".to_owned(),
                }
            }
            Err(e) => {
                let err = format!("unable to convert {} to u64 with error {}", raw_response, e);
                EVMResult {
                    stdout: "".to_owned(),
                    stderr: err,
                }
            }
        };
        return result;
    }

    EVMResult {
        stdout: "".to_owned(),
        stderr: serde_json::to_string(&response.error).unwrap(),
    }
}
```

The `get_block_number` function implements a wrapper around the `eth_blockNumber` method and decodes the hex response to a json string. We could have implemented a more general function, say, `fn eth_rpc_wrapper(provider: ProviderInfo, method: String, parameters: Vec<String>) -> EVMResult` and either returned the raw json rpc result or added per-method decoding match arms, which you are encouraged to implement for the methods of your choosing.

Note that not all provides follow the JSON-RPC style when it comes to error handling. For example, submitting an invalid API key to Alchemy, results in JSON-RPC error:

```json
{ jsonrpc: "2.0", error: Some(RpcResponseError { code: -32000, message: "Must be authenticated!" }), result: None }
```

Infura, on the other hand, does not follow the JSON-RPC route and instead returns a string in stdout with no other error codes or indicators available:

```json
"invalid project id\n"
```

Infura-ating but such is life. We compensate for this idiosyncrasy with the following curl response processor:

```rust
fn get_curl_response(curl_cmd: Vec<String>) -> RpcResponse {
    let response = curl_request(curl_cmd);
    let response = String::from_utf8(response.stdout).unwrap();

    let response: Result<RpcResponse, _> = serde_json::from_str(&response);
    match response {
        Ok(r) => r,
        Err(e) => RpcResponse {
            jsonrpc: "".to_owned(),
            error: Some(RpcResponseError {
                code: -1,
                message: e.to_string(),
            }),
            result: None,
        },
    }
```

Of course, other providers may provide even other response patters and it is up to you to make the necessary adjustments. You may think the convenience of vendor lock-in doesn't look that bad right about now but trust yourself, it is not.

Recall that the `#[marine]` macro brings the Fluence `marine-rust-sdk` into play to compile to the Wasi target and expose the appropriate interfaces. Moreover, note that we link the [`curl` module](./curl-adapter/) to enable our http calls.

At this point we're good to go and compile our code to Wasm:

```bash
./scripts/build.sh
```

which should put `curl_adapter.wasm` and `multi_provider_query.wasm` in the `artifacts` directory. Before we deploy or service to one or more peers, let's check it out locally using the `marine` REPL:

```bash
cd ../  # assuming your are still in the multi-provider-query directory
marine repl configs/Config.toml

Welcome to the Marine REPL (version 0.16.2)
Minimal supported versions
  sdk: 0.6.0
  interface-types: 0.20.0

app service was created with service id = 2429b9fb-c04a-4ed9-9062-400c39e86f72
elapsed time 130.289671ms
```

Let's have a look at what we loaded:

```python
1> interface
Loaded modules interface:
exported data types (combined from all modules):
data ProviderInfo:
  url: string
  name: string
data EVMResult:
  stdout: string
  stderr: string
data MountedBinaryResult:
  ret_code: i32
  error: string
  stdout: []u8
  stderr: []u8

exported functions:
curl_adapter:
  fn curl_request(cmd: []string) -> MountedBinaryResult
multi_provider_query:
  fn get_block_number(provider: ProviderInfo) -> EVMResult

2>
```

If you go back to the source files, you'll see that all the interfaces marked up with the `#[marine]` macro are exposed and available in the REPL. Moreover, note that both the `curl_adapter` and `multi_provider_query` WASM modules are available as the eponymous namespaces with the corresponding (exposed) functions.

Without further ado, let's try to get a the latest block with a couple of the provider urls:

```python
2> call multi_provider_query get_block_number [{"url":"https://eth-mainnet.alchemyapi.io/v2/<YOUR-API_KEY>", "name":"alchemy"}]
result: Object({"stderr": String(""), "stdout": String("{\"block-height\":14992116}")})
 elapsed time: 492.973202ms

3> call multi_provider_query get_block_number [{"url":"https://mainnet.infura.io/v3/0cc023286cae4ab886598ecd14e256fd", "name":"infura"}]
result: Object({"stderr": String(""), "stdout": String("{\"block-height\":14992116}")})
 elapsed time: 589.44887ms

4>
```

Ok, so we called both Alchemy and Infura for the latest block height and got the same result, which is somewhat confidence inspiring. Let's check with a bad API key and keep in mind that we had to "coerce" the Infura response into the JSON-RPC format:

```python
4> call multi_provider_query get_block_number [{"url":"https://eth-mainnet.alchemyapi.io/v2/YOUR-BAD-API_KEY", "name":"alchemy"}]
result: Object({"stderr": String("{\"code\":-32000,\"message\":\"Must be authenticated!\"}"), "stdout": String("")})
 elapsed time: 402.875003ms

5> call multi_provider_query get_block_number [{"url":"https://mainnet.infura.io/v3/YOUR-BAD-API_KEY", "name":"infura"}]
result: Object({"stderr": String("{\"code\":-1,\"message\":\"expected value at line 1 column 1\"}"), "stdout": String("")})
 elapsed time: 399.970977ms
```

While we have been using hosted Ethereum mainnet endpoints, you can easily use other supported (EVM) networks such as [Polygn PoS on Alchemy](https://docs.polygon.technology/docs/develop/alchemy/) or [Polygon PoS on Infura](https://docs.infura.io/infura/networks/polygon-pos/how-to).

Since all looks well, let's deploy our service with the `aqua cli` tool to the `stage` testnet. To see the Fluence default peers for `stage`:

```bash
aqua config default_peers stage
/dns4/stage.fluence.dev/tcp/19001/wss/p2p/12D3KooWHCJbJKGDfCgHSoCuK9q4STyRnVveqLoXAPBbXHTZx9Cv
/dns4/stage.fluence.dev/tcp/19002/wss/p2p/12D3KooWMigkP4jkVyufq5JnDJL6nXvyjeaDNpRfEZqQhsG3sYCU
/dns4/stage.fluence.dev/tcp/19003/wss/p2p/12D3KooWMMGdfVEJ1rWe1nH1nehYDzNEHhg5ogdfiGk88AupCMnf
/dns4/stage.fluence.dev/tcp/19004/wss/p2p/12D3KooWJ4bTHirdTFNZpCS72TAzwtdmavTBkkEXtzo6wHL25CtE
/dns4/stage.fluence.dev/tcp/19005/wss/p2p/12D3KooWAKNos2KogexTXhrkMZzFYpLHuWJ4PgoAhurSAv7o5CWA
/dns4/stage.fluence.dev/tcp/19990/wss/p2p/12D3KooWDcpWuyrMTDinqNgmXAuRdfd2mTdY9VoXZSAet2pDzh6r
```

Also, if you are deploying your own service instances, you need one, or more, keypairs to deploy, authenticate and eventually delete your service. You can use `aqua-cli   to create keys:

```bash
aqua key create
{
    "peerId": "12D3KooWDAM4YDz7WdAWVzxQspeZudL4rqyGmvWUePEvuERNYfLC",
    "secretKey": "SOME-SECRET-KEY",
    "publicKey": "SOME-PUB-KEY"
}
```

Let's deploy to, say, /dns4/stage.fluence.dev/tcp/19005/wss/p2p/12D3KooWAKNos2KogexTXhrkMZzFYpLHuWJ4PgoAhurSAv7o5CWA:

```bash
aqua remote deploy_service \
  --addr /dns4/stage.fluence.dev/tcp/19005/wss/p2p/12D3KooWAKNos2KogexTXhrkMZzFYpLHuWJ4PgoAhurSAv7o5CWA \
  --config-path configs/deployment_cfg.json \
  --service multi-provider-query \
  --sk Bl/RLGRT4SafZyzYVXK4QufvRKTTVn+3kpNsAzDeEQU=
```

Which gives up back our service id and then some:

```bash
Going to upload a module...
2022.06.22 14:53:33 [INFO] created ipfs client to /ip4/134.209.186.43/tcp/5005
2022.06.22 14:53:33 [INFO] connected to ipfs
2022.06.22 14:53:34 [INFO] file uploaded
Going to upload a module...
2022.06.22 14:53:34 [INFO] created ipfs client to /ip4/134.209.186.43/tcp/5005
2022.06.22 14:53:34 [INFO] connected to ipfs
2022.06.22 14:53:37 [INFO] file uploaded
Now time to make a blueprint...
Blueprint id:
a046d3de2d9093df854ab97130f4d1b2dbbb6d9bbe4c445e433deb402b9a8fd3
And your service id is:
"b3094b93-31c5-475b-9919-3b6997461b9d"
```

## Selecting Providers

A large number of EVM nodes are hosted by centralized providers such as [Alchemy](https://www.alchemy.com/), which isn't all that surprising how resource intensive it is to self-host nodes. In addition to hosting nodes, many hosters provide their custom API, REST, GraphQL, etc., to provide a Web2 experience and don't even offer native EVM JSON-RPC access. Alas, that provides a double pain-point for DApp developers: the introduction of a single point of failure with a high exit/migration barrier due to vendor-specific API lock-in.

For our purposes, we choose the following three hosting providers as they provide free EVM JSON-RPC access with a common http header approach:

* [Infura](https://infura.io/)
  * need to sign up for a free account and get API lkey
  * for Ethereum mainnet, our uri is: 

* [Alchemy](https://www.alchemy.com/)
  * need to sign up for a free account and get API lkey
  * for Ethereum mainnet, our uri is: 

* [Linkpool](https://linkpool.io/)
  * no need to sign up or need for an API key
  * is a light client limiting historic queries
  * for Ethereum mainnet, our uri is: https://main-light.eth.linkpool.io
  * does not work with "Accept: application/json"  but only  "Content-Type: application/json" header


## Multi-Provider Queries With Aqua

Now that we have our adapter and  providers, let's think about how we can use a multi-provider query approach to ensure a high likelihood of truth and reliability in our queries. Keep in mind that in addition to our lack of trust in each of the providers, we may also not trust the Fluence peers hosting a service. In that case, we should run every provider request on, say, three or more Fluence nodes. Moreover, we need to parallelize our requests to make sure we don't inadvertently straddle different block times and legitimately providing different responses.

As you may recall, Wasm modules are single threaded and concurrency of service execution is managed at the Aqua level. Parallel execution of a service may be accomplished on one or multiple nodes but either way, you need to deploy multiple service instances, e.g., for k parallel arms, you want k service instances. So in our case, we can deploy our service to, say, three (3) nodes and then execute in parallel each provider request on each of the Fluence nodes, which gives us optimal "coverage": for each request block on each node we expect the same response set. Luckily, Aqua was created exactly to easily implement complex patterns over a variety of topologies. Note that for true parallelization 

```aqua
-- aqua/...aqua

data FunctionAddress:
  peer_id: string
  service_id: string

data Provider:
  name: string
  url: string

data EVMResult:
  stdout: string
  stderr: string

service MultiProviderQuery("service-id"):                 --< interface to our Wasm service
  get_block_number(provider: ProviderInfo) -> EVMResult

-- utility function ot map service id to peer id since we don't have hashmaps in Aqua
func get_service_id(node: string, services: []FunctionAddress) -> string:
  for service in services try:
    if service.peer_id == node:
      res <- service.service_id
  <- res

func pseudo_caller(providers: []Provider, nodes: []string, services: []FunctionAddress) -> []string:
  result: *string
  for node <- nodes par:
    on node:
      for provider <- providers par:
        MultiProviderQuery 
        res <- get_block_number(provider.url)
        result <- (provider.name, node, res)
```


Time to turn to Aqua to get things done.

```aqua
-- aqua/multi_provider.aqua

data EVMResult:
  stdout: string
  stderr: string

data ProviderInfo:
  url: string
  name: string

data Providers:
    urls: []ProviderInfo

data 

service MyOp("op"):
  identity(x:string) -> string
  array_length(providers: []ProviderInfo) -> i64

service MultiProviderQuery("service-id"):
  get_balance(provider: ProviderInfo, account: string, block_height: string) -> EVMResult
  get_block_number(provider: ProviderInfo) -> EVMResult

func get_block_heights(providers: Providers, service_id: string, node: string) -> []EVMResult, i64:
    block_heights: *EVMResult
    -- n <- n_urls(providers)
    n <- MyOp.array_length(providers.urls)

    if n > 0:
      on node:
        MultiProviderQuery service_id
        for provider <- providers.urls par:
          block_heights <- MultiProviderQuery.get_block_number(provider)
      join block_heights[n-1]

    <- block_heights, n
```


Par 
```
func get_block_heights(providers: Providers, service_id: string, node: string) -> []EVMResult, i64:
    block_heights: *EVMResult
    -- n <- n_urls(providers)
    n <- MyOp.array_length(providers.urls)

    if n > 0:
      on node:
        MultiProviderQuery service_id
        for provider <- providers.urls par:
          block_heights <- MultiProviderQuery.get_block_number(provider)
      join block_heights[n-1]

    <- block_heights, n
```


## Let's Persist Stuff

Coming soon.
