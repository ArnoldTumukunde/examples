/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/.
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.3.0-222
 *
 */
import { FluencePeer } from "@fluencelabs/fluence";
import {
  ResultCodes,
  RequestFlow,
  RequestFlowBuilder,
  CallParams,
} from "@fluencelabs/fluence/dist/internal/compilerSupport/v1";

// Services

export interface CalcDef {
  add: (n: number, callParams: CallParams<"n">) => void;
  divide: (n: number, callParams: CallParams<"n">) => void;
  getResult: (callParams: CallParams<null>) => number;
  multiply: (n: number, callParams: CallParams<"n">) => void;
  reset: (callParams: CallParams<null>) => void;
  subtract: (n: number, callParams: CallParams<"n">) => void;
}

export function registerCalc(service: CalcDef): void;
export function registerCalc(serviceId: string, service: CalcDef): void;
export function registerCalc(peer: FluencePeer, service: CalcDef): void;
export function registerCalc(
  peer: FluencePeer,
  serviceId: string,
  service: CalcDef
): void;
export function registerCalc(...args) {
  let peer: FluencePeer;
  let serviceId;
  let service;
  if (args[0] instanceof FluencePeer) {
    peer = args[0];
  } else {
    peer = FluencePeer.default;
  }

  if (typeof args[0] === "string") {
    serviceId = args[0];
  } else if (typeof args[1] === "string") {
    serviceId = args[1];
  } else {
    serviceId = "calc";
  }

  if (!(args[0] instanceof FluencePeer) && typeof args[0] === "object") {
    service = args[0];
  } else if (typeof args[1] === "object") {
    service = args[1];
  } else {
    service = args[2];
  }

  peer.internals.callServiceHandler.use((req, resp, next) => {
    if (req.serviceId !== serviceId) {
      next();
      return;
    }

    if (req.fnName === "add") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          n: req.tetraplets[0],
        },
      };
      resp.retCode = ResultCodes.success;
      service.add(req.args[0], callParams);
      resp.result = {};
    }

    if (req.fnName === "divide") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          n: req.tetraplets[0],
        },
      };
      resp.retCode = ResultCodes.success;
      service.divide(req.args[0], callParams);
      resp.result = {};
    }

    if (req.fnName === "getResult") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {},
      };
      resp.retCode = ResultCodes.success;
      resp.result = service.getResult(callParams);
    }

    if (req.fnName === "multiply") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          n: req.tetraplets[0],
        },
      };
      resp.retCode = ResultCodes.success;
      service.multiply(req.args[0], callParams);
      resp.result = {};
    }

    if (req.fnName === "reset") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {},
      };
      resp.retCode = ResultCodes.success;
      service.reset(callParams);
      resp.result = {};
    }

    if (req.fnName === "subtract") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          n: req.tetraplets[0],
        },
      };
      resp.retCode = ResultCodes.success;
      service.subtract(req.args[0], callParams);
      resp.result = {};
    }

    next();
  });
}

// Functions
