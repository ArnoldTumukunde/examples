/**
 *
 * This file is auto-generated. Do not edit manually: changes may be erased.
 * Generated by Aqua compiler: https://github.com/fluencelabs/aqua/.
 * If you find any bugs, please write an issue on GitHub: https://github.com/fluencelabs/aqua/issues
 * Aqua version: 0.2.0-SNAPSHOT
 *
 */
import { FluencePeer } from "@fluencelabs/fluence";
import {
  ResultCodes,
  RequestFlow,
  RequestFlowBuilder,
  CallParams,
} from "@fluencelabs/fluence/dist/internal/compilerSupport/v1";

// Services

export function registerCalc(service: {
  add: (n: number, callParams: CallParams<"n">) => Promise<void>;
  divide: (n: number, callParams: CallParams<"n">) => Promise<void>;
  getResult: (callParams: CallParams<null>) => Promise<number>;
  multiply: (n: number, callParams: CallParams<"n">) => Promise<void>;
  reset: (callParams: CallParams<null>) => Promise<void>;
  subtract: (n: number, callParams: CallParams<"n">) => Promise<void>;
}): void;
export function registerCalc(
  serviceId: string,
  service: {
    add: (n: number, callParams: CallParams<"n">) => Promise<void>;
    divide: (n: number, callParams: CallParams<"n">) => Promise<void>;
    getResult: (callParams: CallParams<null>) => Promise<number>;
    multiply: (n: number, callParams: CallParams<"n">) => Promise<void>;
    reset: (callParams: CallParams<null>) => Promise<void>;
    subtract: (n: number, callParams: CallParams<"n">) => Promise<void>;
  }
): void;
export function registerCalc(
  peer: FluencePeer,
  service: {
    add: (n: number, callParams: CallParams<"n">) => Promise<void>;
    divide: (n: number, callParams: CallParams<"n">) => Promise<void>;
    getResult: (callParams: CallParams<null>) => Promise<number>;
    multiply: (n: number, callParams: CallParams<"n">) => Promise<void>;
    reset: (callParams: CallParams<null>) => Promise<void>;
    subtract: (n: number, callParams: CallParams<"n">) => Promise<void>;
  }
): void;
export function registerCalc(
  peer: FluencePeer,
  serviceId: string,
  service: {
    add: (n: number, callParams: CallParams<"n">) => Promise<void>;
    divide: (n: number, callParams: CallParams<"n">) => Promise<void>;
    getResult: (callParams: CallParams<null>) => Promise<number>;
    multiply: (n: number, callParams: CallParams<"n">) => Promise<void>;
    reset: (callParams: CallParams<null>) => Promise<void>;
    subtract: (n: number, callParams: CallParams<"n">) => Promise<void>;
  }
): void;
export function registerCalc(...args) {
  let peer: FluencePeer;
  let serviceId;
  let service;
  if (args[0] instanceof FluencePeer) {
    peer = args[0];
  } else {
    peer = FluencePeer.default;
  }

  if (typeof args[0] === "string") {
    serviceId = args[0];
  } else if (typeof args[1] === "string") {
    serviceId = args[1];
  } else {
    serviceId = "calc";
  }

  if (!(args[0] instanceof FluencePeer) && typeof args[0] === "object") {
    service = args[0];
  } else if (typeof args[1] === "object") {
    service = args[1];
  } else {
    service = args[2];
  }

  peer.callServiceHandler.use(async (req, resp, next) => {
    if (req.serviceId !== serviceId) {
      await next();
      return;
    }

    if (req.fnName === "add") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          n: req.tetraplets[0],
        },
      };
      resp.retCode = ResultCodes.success;
      await service.add(req.args[0], callParams);
      resp.result = {};
    }

    if (req.fnName === "divide") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          n: req.tetraplets[0],
        },
      };
      resp.retCode = ResultCodes.success;
      await service.divide(req.args[0], callParams);
      resp.result = {};
    }

    if (req.fnName === "getResult") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {},
      };
      resp.retCode = ResultCodes.success;
      resp.result = await service.getResult(callParams);
    }

    if (req.fnName === "multiply") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          n: req.tetraplets[0],
        },
      };
      resp.retCode = ResultCodes.success;
      await service.multiply(req.args[0], callParams);
      resp.result = {};
    }

    if (req.fnName === "reset") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {},
      };
      resp.retCode = ResultCodes.success;
      await service.reset(callParams);
      resp.result = {};
    }

    if (req.fnName === "subtract") {
      const callParams = {
        ...req.particleContext,
        tetraplets: {
          n: req.tetraplets[0],
        },
      };
      resp.retCode = ResultCodes.success;
      await service.subtract(req.args[0], callParams);
      resp.result = {};
    }

    await next();
  });
}

// Functions

export async function demoCalculation(config?: {
  ttl?: number;
}): Promise<number>;
export async function demoCalculation(
  peer: FluencePeer,
  config?: { ttl?: number }
): Promise<number>;
export async function demoCalculation(...args) {
  let peer: FluencePeer;

  let config;
  if (args[0] instanceof FluencePeer) {
    peer = args[0];
    config = args[1];
  } else {
    peer = FluencePeer.default;
    config = args[0];
  }

  let request: RequestFlow;
  const promise = new Promise<number>((resolve, reject) => {
    const r = new RequestFlowBuilder()
      .disableInjections()
      .withRawScript(
        `
     (xor
 (seq
  (seq
   (seq
    (seq
     (seq
      (seq
       (call %init_peer_id% ("getDataSrv" "-relay-") [] -relay-)
       (call %init_peer_id% ("calc" "add") [10])
      )
      (call %init_peer_id% ("calc" "multiply") [5])
     )
     (call %init_peer_id% ("calc" "subtract") [8])
    )
    (call %init_peer_id% ("calc" "divide") [6])
   )
   (call %init_peer_id% ("calc" "getResult") [] res)
  )
  (xor
   (call %init_peer_id% ("callbackSrv" "response") [res])
   (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 1])
  )
 )
 (call %init_peer_id% ("errorHandlingSrv" "error") [%last_error% 2])
)

                 `
      )
      .configHandler((h) => {
        h.on("getDataSrv", "-relay-", async () => {
          return peer.connectionInfo.connectedRelays[0] || null;
        });

        h.onEvent("callbackSrv", "response", async (args) => {
          const [res] = args;
          resolve(res);
        });

        h.onEvent("errorHandlingSrv", "error", async (args) => {
          const [err] = args;
          reject(err);
        });
      })
      .handleScriptError(reject)
      .handleTimeout(() => {
        reject("Request timed out for demoCalculation");
      });
    if (config && config.ttl) {
      r.withTTL(config.ttl);
    }
    request = r.build();
  });
  await peer.initiateFlow(request!);
  return promise;
}
